#!/bin/bash

# Using RabbitVCS diff seems broken. Command to launch GUI of changes with
# previous revision of the file
svndiff() {

    while [[ $# -gt 0 ]]
    do
    key="$1"

    case $key in
        -r|--rev)
        REVISION="$2"
        shift # past argument
        shift # past value
        ;;
        *)    # unknown option
        FILE=$1
        shift # past argument
        ;;
    esac
    done

    if [[ -z "${FILE+x}" ]]
    then
        echo "[ERROR] File not set" >&2
        exit 1
    fi

    if [[ -z "${REVISION+x}" ]]
    then
        svn diff -r PREV:HEAD $FILE --diff-cmd meld
    else
        svn diff -r $REVISION $FILE --diff-cmd meld
    fi

    unset REVISION
    unset FILE
}

# Adapted from: https://stackoverflow.com/questions/9600382/svn-command-to-delete-all-locally-missing-files
svnrmmissing() {

    svn status | grep '^!' | sed -e s/"!       "//g | while read line
    do
        svn rm "$line"
    done

}

svnaddnew() {

    svn status | grep '^?' | sed -e s/"?       "//g | while read line
    do
        svn add "$line"
    done

}

svnlog() {

    svn log | perl -l40pe 's/^-+/\n/'

}

sqlplus() {
    # All arg options:
    # - $*
    # - $@
    # If using the $@ syntax, it seems to read values line by line, unless you
    # use it with echo, or first assign it to a variable, e.g args="$@". $*
    # seems to get it to a single line fine.
    rlwrap sqlplus "$*"
}

proj() {
    projName=$1
    if [[ "$projName" != "" ]]
    then
        cd ~/Projects/$projName
    else
        cd ~/Projects
    fi
}

# Wrap function body in () to create a sub-shell. This allows us to exit without
# closing the terminal in the process. Idea taken from here:
# https://stackoverflow.com/questions/32684119/exit-when-one-process-in-pipe-fails
sqlb() {(
    # Exit function on any error
    set -e

    # pipefail so when getting branch name, which we pipe to `tr`, if it fails
    # i.e. not a branch, this process exits
    set -o pipefail

    # Find which project I'm in. All my projects are in the folder `$HOME/Projects/Oracle`
    # so we remove the start of the string using bash substring removal
    proj_home="$HOME/Projects/Oracle"
    proj_relative_path="${PWD#${proj_home}\/}"

    # This will give us something like:
    # * foo
    # * foo/source/plsql
    # So use `cut` to remove the path delimiter (`/`) and get the first field (foo)
    # This should give us the project name, which we later use to drive the connect
    # string.
    proj_name=$(echo $proj_relative_path | cut -d "/" -f1)

    # Connect string is driven from folder/project name and branch name. For this
    # to work, root folder (proj_name) must match as it is in cloudlab. Replace dashes
    # with underscores - connect string won't use dashes.
    branch_name=$(git rev-parse --abbrev-ref HEAD | tr "-" "_")
    connect_string=$(echo "xgbu_ace_${proj_name}_${branch_name}")

    # Use lowercase just to make things nicer.
    connect_string=$(echo "${connect_string}" | tr "[:upper:]" "[:lower:]")

    printf "sql ${G_ACDC_SCHEMA}@${connect_string}\n"

    # $* - pass any additional arguments I passed when calling the function
    # We need to split this into a conditional because SQLcl still treats it as
    # a value even if an empty string is passed in and it throws an error trying
    # to connect.
    if [[ "$*" != "" ]]
    then
        sql -L ${G_ACDC_SCHEMA}/${G_ACDC_SCHEMA_PASSWORD}@${connect_string} "$*"
    else
        sql -L ${G_ACDC_SCHEMA}/${G_ACDC_SCHEMA_PASSWORD}@${connect_string}
    fi
)}
